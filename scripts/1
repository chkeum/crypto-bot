#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

backup() {
  local f="$1"
  if [ -f "$f" ]; then cp -f "$f" "$f.bak"; fi
}

# ====== exchange_binance.py ======
echo "[patch] write bot/exchange_binance.py"
backup "$ROOT/bot/exchange_binance.py"
cat > "$ROOT/bot/exchange_binance.py" <<'PY'
from loguru import logger
from typing import Dict, Any, Optional, Tuple
import ccxt

class BinanceUSDMExchange:
    def __init__(self, api_key: str, api_secret: str, is_testnet: bool = True, default_leverage: int = 5):
        self.exchange = ccxt.binanceusdm({
            "apiKey": api_key,
            "secret": api_secret,
            "options": {"defaultType": "future"},
            "enableRateLimit": True,
        })
        self.ex = self.exchange
        try:
            self.exchange.set_sandbox_mode(bool(is_testnet))
        except Exception:
            pass
        try:
            self.exchange.load_markets()
        except Exception:
            pass
        self.default_leverage = int(default_leverage or 1)
        logger.info(f"[BINANCE] Sandbox: {bool(is_testnet)}")

    def get_position_detail(self, symbol: str) -> Tuple[Optional[str], float, Optional[float]]:
        try:
            positions = self.exchange.fetch_positions()
        except Exception as e:
            logger.warning(f"[BINANCE]{symbol} fetch_positions(all) failed: {e}")
            return None, 0.0, None
        target = None
        for p in positions or []:
            try:
                contracts = float(p.get("contracts") or 0.0)
            except Exception:
                contracts = 0.0
            if p.get("symbol") == symbol and abs(contracts) > 0:
                target = p
                break
        if not target:
            try:
                m = self.exchange.market(symbol)
                mid = m.get("id")
                for p in positions or []:
                    info = p.get("info") or {}
                    try:
                        contracts = float(p.get("contracts") or 0.0)
                    except Exception:
                        contracts = 0.0
                    if info.get("symbol") == mid and abs(contracts) > 0:
                        target = p
                        break
            except Exception:
                pass
        if not target:
            return None, 0.0, None
        amt = float(target.get("contracts") or 0.0)
        side = target.get("side") or ("long" if amt > 0 else ("short" if amt < 0 else None))
        try:
            entry = float(target.get("entryPrice") or 0.0) or None
        except Exception:
            entry = None
        return side, abs(amt), entry

    def _get_position_size(self, symbol: str) -> float:
        _, size, _ = self.get_position_detail(symbol)
        return float(size or 0.0)

    def set_leverage(self, symbol: str, leverage: Optional[int] = None) -> None:
        lev = int(leverage or self.default_leverage or 1)
        try:
            m = self.exchange.market(symbol)
            self.exchange.set_leverage(lev, symbol, params={"marginMode": m.get("marginMode", "cross")})
        except Exception as e:
            logger.warning(f"[BINANCE] set_leverage failed: {e}")

    def open_market(self, symbol: str, side: str, amount: float, leverage: Optional[int] = None) -> Dict[str, Any]:
        side = side.lower()
        order_side = "buy" if side == "long" else "sell"
        self.set_leverage(symbol, leverage)
        order = self.exchange.create_market_order(symbol, order_side, amount=amount, params={"reduceOnly": False})
        return {"status": "submitted", "exchange_order": order}

    def close_all(self, symbol: str) -> Dict[str, Any]:
        size = self._get_position_size(symbol)
        if abs(size) <= 0:
            return {"status": "no_position", "symbol": symbol}
        exit_side = "sell" if size > 0 else "buy"
        try:
            order = self.exchange.create_market_order(symbol, exit_side, amount=abs(size), params={"reduceOnly": True})
            return {"status": "submitted", "exchange_order": order}
        except Exception as e:
            logger.error(f"[BINANCE] close_all failed: {e}")
            return {"status": "error", "error": str(e)}

    def place_bracket(self, symbol: str, side: str, amount: float,
                      sl_price: Optional[float], tp_price: Optional[float],
                      tp_as_market: bool = True, working_type: str = "CONTRACT_PRICE") -> Dict[str, Any]:
        side = side.lower()
        if not sl_price and not tp_price:
            return {"status": "skipped", "reason": "no sl/tp"}
        exit_side = "sell" if side == "long" else "buy"
        base_params = {"reduceOnly": True, "workingType": working_type}
        res: Dict[str, Any] = {"status": "ok"}
        try:
            if sl_price:
                res["sl"] = self.exchange.create_order(symbol, "STOP_MARKET", exit_side, amount, params={**base_params, "stopPrice": float(sl_price)})
            if tp_price:
                if tp_as_market:
                    res["tp"] = self.exchange.create_order(symbol, "TAKE_PROFIT_MARKET", exit_side, amount, params={**base_params, "stopPrice": float(tp_price)})
                else:
                    res["tp"] = self.exchange.create_order(symbol, "TAKE_PROFIT", exit_side, amount, price=float(tp_price), params={**base_params, "stopPrice": float(tp_price)})
        except Exception as e:
            logger.warning(f"[BINANCE]{symbol} place_bracket failed: {e}")
            res["status"] = "error"
            res["error"] = str(e)
        return res

    def cancel_reduces_if_flat(self, symbol: str) -> None:
        size = self._get_position_size(symbol)
        if abs(size) > 0:
            return
        try:
            for o in self.exchange.fetch_open_orders(symbol) or []:
                info = o.get("info", {})
                ro = str(info.get("reduceOnly", info.get("reduce_only", ""))).lower() in ("true", "1")
                if ro:
                    try:
                        self.exchange.cancel_order(o["id"], symbol)
                    except Exception:
                        pass
        except Exception:
            pass
PY

# ====== restore_bootstrap.py ======
echo "[patch] write bot/restore_bootstrap.py"
backup "$ROOT/bot/restore_bootstrap.py"
cat > "$ROOT/bot/restore_bootstrap.py" <<'PY'
from __future__ import annotations
from typing import Optional, Tuple
from loguru import logger
from .config import STRAT_SYMBOLS

_enabled = False

def enable_restore_on_start() -> None:
    global _enabled
    _enabled = True
    logger.info("[RESTORE] bootstrap enabled")

def _get_position_detail(engine, symbol: str) -> Tuple[Optional[str], float, Optional[float]]:
    if hasattr(engine, "get_position_detail"):
        try:
            return engine.get_position_detail(symbol)
        except Exception:
            pass
    ex = getattr(engine, "ex", None)
    if ex is None:
        return None, 0.0, None
    try:
        pos_list = ex.fetch_positions()
    except Exception as e:
        logger.warning(f"[RESTORE]{symbol} fetch_positions(all) failed: {e}")
        return None, 0.0, None
    target = None
    for p in pos_list or []:
        try:
            contracts = float(p.get("contracts") or 0.0)
        except Exception:
            contracts = 0.0
        if p.get("symbol") == symbol and abs(contracts) > 0:
            target = p
            break
    if not target:
        try:
            m = ex.market(symbol)
            market_id = m.get('id')
            for p in pos_list or []:
                info = p.get("info") or {}
                try:
                    contracts = float(p.get("contracts") or 0.0)
                except Exception:
                    contracts = 0.0
                if info.get("symbol") == market_id and abs(contracts) > 0:
                    target = p
                    break
        except Exception:
            pass
    if not target:
        return None, 0.0, None
    amt = float(target.get("contracts") or 0.0)
    side = target.get("side") or ("long" if amt > 0 else ("short" if amt < 0 else None))
    try:
        entry = float(target.get("entryPrice") or 0.0) or None
    except Exception:
        entry = None
    return side, abs(amt), entry

def _has_reduce_only_orders(ex, symbol: str) -> bool:
    try:
        ods = ex.fetch_open_orders(symbol)
    except Exception as e:
        logger.warning(f"[RESTORE]{symbol} fetch_open_orders failed: {e}")
        return False
    for o in ods or []:
        info = o.get("info") or {}
        ro = str(info.get("reduceOnly", info.get("reduce_only", ""))).lower() in ("true","1")
        if ro:
            return True
    return False

def _restore_on_start(engine) -> None:
    ex = getattr(engine, "ex", None)
    if not ex:
        logger.warning("[RESTORE] engine.ex missing; skip restore")
        return
    syms = [s.strip() for s in STRAT_SYMBOLS.split(",") if s.strip()]
    for sym in syms:
        side, size, entry = _get_position_detail(engine, sym)
        if not side or size <= 0:
            logger.info(f"[RESTORE]{sym} no position; nothing to restore.")
            continue
        has_ro = _has_reduce_only_orders(ex, sym)
        logger.info(f"[RESTORE]{sym} side={side} size={size} entry={entry} reduceOnly_exists={has_ro}")
        if not has_ro:
            logger.warning(f"[RESTORE]{sym} reduceOnly SL/TP not found. (manual check recommended)")

def maybe_run_restore_on_start(app, engine) -> None:
    if _enabled:
        try:
            _restore_on_start(engine)
        except Exception as e:
            logger.warning(f"[RESTORE] failed: {e}")
PY

# ====== debug_endpoints.py ======
echo "[patch] write bot/debug_endpoints.py"
backup "$ROOT/bot/debug_endpoints.py"
cat > "$ROOT/bot/debug_endpoints.py" <<'PY'
from __future__ import annotations
from typing import Any, Dict, Optional
from fastapi import Depends, FastAPI, Header, HTTPException
from loguru import logger

try:
    from .config import WEBHOOK_TOKEN
except Exception:
    WEBHOOK_TOKEN = None

def _auth_guard(x_token: Optional[str] = Header(default=None)) -> None:
    if WEBHOOK_TOKEN:
        if not x_token or x_token != WEBHOOK_TOKEN:
            raise HTTPException(status_code=401, detail="Unauthorized")

def _f(v, default=None):
    try:
        if v is None: return default
        return float(v)
    except Exception:
        return default

def mount_debug(app: FastAPI, engine: Any) -> None:
    if engine is None or getattr(engine, "ex", None) is None:
        logger.warning("[DEBUG] engine/ex missing; debug endpoints limited")

    @app.get("/debug/positions")
    def debug_positions(_: None = Depends(_auth_guard)) -> Dict[str, Any]:
        ex = getattr(engine, "ex", None)
        resp: Dict[str, Any] = {"positions": [], "note": ""}
        if ex is None:
            resp["note"] = "engine.ex not available"
            return resp
        try:
            pos_list = ex.fetch_positions()
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"fetch_positions failed: {e}")

        def is_reduce(o: Dict[str, Any]) -> bool:
            info = (o or {}).get("info") or {}
            ro = str(info.get("reduceOnly", info.get("reduce_only",""))).lower()
            return ro in ("true","1") or (o.get("reduceOnly") is True)

        opens_cache: Dict[str, Any] = {}

        for p in pos_list or []:
            try:
                amt = float(p.get("contracts") or 0.0)
            except Exception:
                amt = 0.0
            if abs(amt) <= 0:
                continue
            sym = p.get("symbol")
            side = p.get("side") or ("long" if amt > 0 else ("short" if amt < 0 else None))
            item = {
                "symbol": sym,
                "contracts": abs(amt),
                "side": side,
                "entryPrice": _f(p.get("entryPrice")),
                "unrealizedPnl": _f(p.get("unrealizedPnl")),
                "leverage": _f(p.get("leverage")),
                "reduceOnly": {"SL": None, "TP": None},
                "raw": p,
            }
            try:
                if sym not in opens_cache:
                    opens_cache[sym] = ex.fetch_open_orders(sym)
                ro = [o for o in opens_cache[sym] or [] if is_reduce(o)]

                def trig(o): return _f(o.get("stopPrice") or o.get("triggerPrice"))
                sls = [o for o in ro if (o.get("type","").upper() in ("STOP","STOP_MARKET"))]
                tps = [o for o in ro if (o.get("type","").upper() in ("TAKE_PROFIT","TAKE_PROFIT_MARKET"))]
                if sls:
                    sls.sort(key=lambda o: trig(o) or 0.0)
                    item["reduceOnly"]["SL"] = trig(sls[0])
                if tps:
                    tps.sort(key=lambda o: trig(o) or 0.0)
                    item["reduceOnly"]["TP"] = trig(tps[0])
            except Exception as e:
                logger.warning(f"[DEBUG] fetch_open_orders({sym}) failed: {e}")
            resp["positions"].append(item)

        resp["note"] = "attach X-Token if WEBHOOK_TOKEN is set"
        return resp
PY

# ====== main.py 자동 패치 (debug mount + restore 부트스트랩) ======
echo "[patch] patch bot/main.py (mount debug & restore after engine init)"
backup "$ROOT/bot/main.py"
python - <<'PY'
import pathlib, re

p = pathlib.Path("bot/main.py")
s = p.read_text()

# 1) import 보강
if "from .restore_bootstrap import enable_restore_on_start" not in s:
    s = s.replace("from loguru import logger", "from loguru import logger\nfrom .restore_bootstrap import enable_restore_on_start")

# 2) enable_restore_on_start()를 app 생성 전에 1회만 삽입
if "enable_restore_on_start()" not in s:
    s = s.replace("app = FastAPI", "enable_restore_on_start()\n\napp = FastAPI")

# 3) 엔진 생성 직후 debug mount + restore 호출 삽입
pat = re.compile(r"(engine\s*=\s*.*BinanceUSDMExchange[^\n]*\n)", re.M)
block = r"""\1
# --- debug & restore mounts ---
try:
    from .debug_endpoints import mount_debug
    mount_debug(app, engine)
except Exception as _e:
    from loguru import logger as _logger
    _logger.warning(f"[DEBUG] mount failed: {_e}")
try:
    from .restore_bootstrap import maybe_run_restore_on_start
    maybe_run_restore_on_start(app, engine)
except Exception as _e:
    from loguru import logger as _logger
    _logger.warning(f"[RESTORE] bootstrap call failed: {_e}")
# --------------------------------
"""
s2 = pat.sub(block, s, count=1)
if s2 == s:
    # fallback: 파일 끝에 붙이기
    s2 = s + "\n# fallback mounts\n" + block

p.write_text(s2)
print("main.py patched")
PY


# ====== push_and_deploy.sh (SKIP_GIT_PULL=1로 로컬코드 바로 배포) ======
echo "[patch] write scripts/push_and_deploy.sh"
backup "$ROOT/scripts/push_and_deploy.sh"
cat > "$ROOT/scripts/push_and_deploy.sh" <<'PY'
#!/usr/bin/env bash
set -euo pipefail
cd "$(dirname "$0")/.."

BRANCH="${BRANCH:-$(git rev-parse --abbrev-ref HEAD)}"
MSG="${1:-auto deploy}"

echo "[push+deploy] 현재 브랜치: $BRANCH"

if ! git diff --quiet || ! git diff --cached --quiet; then
  echo "[push+deploy] 변경사항 발견 → commit & push"
  git add -A
  git commit -m "$MSG"
  git push origin "$BRANCH"
else
  echo "[push+deploy] 변경사항 없음 → push 생략"
fi

echo "[push+deploy] deploy_wsl.sh 실행 (SKIP_GIT_PULL=1)"
SKIP_GIT_PULL=1 bash scripts/deploy_wsl.sh
PY
chmod +x "$ROOT/scripts/push_and_deploy.sh"

# ====== deploy_wsl.sh (tmux+로그+헬스체크+tail -f) ======
echo "[patch] write scripts/deploy_wsl.sh"
backup "$ROOT/scripts/deploy_wsl.sh"
cat > "$ROOT/scripts/deploy_wsl.sh" <<'PY'
#!/usr/bin/env bash
set -euo pipefail
ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT"

echo "[deploy] repo: $ROOT"
if [ "${SKIP_GIT_PULL:-0}" = "1" ]; then
  echo "[deploy] skip git pull (SKIP_GIT_PULL=1)"
else
  echo "[deploy] git pull..."
  git pull --ff-only
fi

echo "[deploy] venv check..."
if [ ! -d ".venv" ]; then python3 -m venv .venv; fi
source .venv/bin/activate

echo "[deploy] deps..."
pip install -r requirements.txt -q

LOGDIR="$ROOT/logs"
mkdir -p "$LOGDIR"
LOGFILE="$LOGDIR/bot-$(date +%Y%m%d).log"
echo "[deploy] prepare log dir: $LOGDIR"

echo "[deploy] kill old tmux session: bot"
tmux kill-session -t bot 2>/dev/null || true

echo "[deploy] start tmux session: bot"
tmux new-session -d -s bot "bash -lc 'source .venv/bin/activate && uvicorn bot.main:app --host 127.0.0.1 --port 8000 2>&1 | tee -a \"$LOGFILE\"'"

echo "[deploy] health check..."
ok=0
for i in {1..30}; do
  if curl -fsS http://127.0.0.1:8000/health >/dev/null 2>&1; then
    echo "[deploy] OK: http://127.0.0.1:8000/health"
    ok=1
    break
  fi
  sleep 1
done

if [ "$ok" != "1" ]; then
  echo "[deploy] health check FAILED"
  echo "----- last 200 log lines -----"
  tail -n 200 "$LOGFILE" || true
  exit 1
fi

echo "[deploy] log file: $LOGFILE"
echo "[deploy] tail -f (Ctrl+C로 종료; 봇은 계속 동작)"
echo "============================================================"
tail -f "$LOGFILE"
PY
chmod +x "$ROOT/scripts/deploy_wsl.sh"

echo "[patch] all done."

